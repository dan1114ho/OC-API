
import async from 'async';
import _ from 'lodash';
import activities from '../constants/activities';
import { planId } from '../lib/utils';
import { appStripe, extractFees } from '../gateways/stripe';
import models, { sequelize } from '../models';
import errors from '../lib/errors';
import emailLib from '../lib/email';
import currencies from '../constants/currencies';
import config from 'config';
import debugLib from 'debug';
const debug = debugLib("webhook");

const {
  Activity,
  Order,
  Collective,
  Subscription,
  Transaction,
  User
} = models;

export default function stripeWebhook(req, res, next) {
  const { body } = req;
  const isProduction = process.env.NODE_ENV === 'production';

  // Stripe send test events to production as well
  // don't do anything if the event is not livemode
  if (isProduction && !body.livemode) {
    return res.sendStatus(200);
  }

  async.auto({
    fetchEvent: (cb) => {

      /**
       * We check the event on stripe to be sure we don't get a fake event from
       * someone else
       */
      appStripe.events.retrieve(body.id, {
        stripe_account: body.user_id
      })
      .then(event => {
        if (event.type !== 'invoice.payment_succeeded') {
          return cb(new errors.BadRequest('Wrong event type received'));
        }

        const invoice = event.data.object;
        const invoiceLineItems = invoice.lines.data;
        const stripeSubscription = _.find(invoiceLineItems, { type: 'subscription' });

        /**
         * With connected accounts we get all the events of the account
         * We will return a 200 if the plan is not in our format (not generated by us)
         * Example: Ruby together has a subscription model outside of us.
         * https://dashboard.stripe.com/acct_15avvkAcWgwn5pBt/events/evt_17oYejAcWgwn5pBtRo5gRiyY
         */
        if (planId(stripeSubscription.plan) !== stripeSubscription.plan.id) {
          debug("fetchEvent", "unrecognized plan id", planId(stripeSubscription.plan), stripeSubscription.plan.id);
          return res.sendStatus(200);
        }

        /*
         * In case we get $0 order, return 200. Otherwise, Stripe will keep pinging us.
         */
        if (event.data.object.amount_due === 0) {
          debug("fetchEvent", "event.data.object.amount_due is 0");
          return res.sendStatus(200);
        }

        cb(null, {
          event,
          stripeSubscription
        });
      })
      .catch(cb);
    },

    createActivity: ['fetchEvent', (cb, results) => {
      // Only save activity when the event is valid
      Activity.create({
        type: activities.WEBHOOK_STRIPE_RECEIVED,
        data: {
          event: results.fetchEvent.event,
          stripeAccount: body.user_id,
          eventId: body.id,
          dashboardUrl: `https://dashboard.stripe.com/${body.user_id}/events/${body.id}`
        }
      })
      .then(activity => cb(null, activity))
      .catch(cb);
    }],

    fetchOrder: ['createActivity', (cb, results) => {
      const stripeSubscriptionId = results.fetchEvent.stripeSubscription.id;

      Order.findOne({
        include: [
          { model: User, as: 'createdByUser' },
          { model: Collective, as: 'collective' },
          { model: Subscription, where: { stripeSubscriptionId } },
          { model: models.PaymentMethod, as: 'paymentMethod' }
        ]
      })
      .then((order) => {
        debug("fetchOrder", order && order.dataValues);
        /**
         * Stripe doesn't make a difference between development, test, staging
         * environments. If we get a webhook from another env,
         * `transaction.Subscription.stripeSubscriptionId`
         * will not be found and throw an error. Stripe will retry to send the webhook
         * if it doesn't get a 2XX status code.
         * For non-production environments, we will simply return 200 to avoid
         * the retry on Stripe side (and the email from Stripe support).
         */
        if (!order && !isProduction) {
          debug("fetchOrder", "order not found with subscription id", stripeSubscriptionId);
          return res.sendStatus(200);
        }

        if (!order) {
          return cb(new errors.BadRequest('Order not found: unknown subscription id'));
        }

        return cb(null, order);
      })
      .catch(cb)
    }],

    confirmUniqueChargeId: ['fetchOrder', (cb, results) => {
      const chargeId = results.fetchEvent.event.data.object.charge;
      const orderId = results.fetchOrder.id;
      debug("confirmUniqueChargeId", chargeId);
      sequelize.query(`
        SELECT * FROM "Transactions"
        WHERE 
          "OrderId" = ${orderId} AND
          CAST(data->'charge'->'id' AS TEXT) like '%${chargeId}%' AND
          "deletedAt" IS NULL
        `.replace(/\s\s+/g, ' '),
        {
          model: Transaction
        })
      .then(t => {
        if (t.length > 0) {
          cb(new errors.BadRequest(`This chargeId: ${chargeId} already exists.`))
        } else {
          cb(null, true);
        }
      })
    }],

    // Extra check - This may not be needed.
    validatePaymentMethod: ['confirmUniqueChargeId', (cb, results) => {

      const customer = results.fetchEvent.event.data.object.customer;
      const order = results.fetchOrder;

      if (!customer) {
        return cb(new errors.BadRequest(`Customer Id not found. Order id: ${order.id}`));
      }
      debug("validatePaymentMethod", "customer:", customer);
      if (!order.paymentMethod) {
        return cb(new errors.BadRequest('PaymentMethod not found'));        
      }

      // For old subscriptions, they still reference the old customerId on the host stripe account
      if (order.paymentMethod.customerId === customer) {
        return cb();
      }

      // We need to iterate through the PaymentMethod.data.customerIdForHost[stripeAccount]
      if (order.paymentMethod.data.customerIdForHost) {
        debug("validatePaymentMethod", "order.paymentMethod.data.customerIdForHost", order.paymentMethod.data.customerIdForHost);
        Object.keys(order.paymentMethod.data.customerIdForHost).forEach(hostStripeAccountId => {
          debug(order.paymentMethod.data.customerIdForHost[hostStripeAccountId],"===", customer);
          debug("hostStripeAccountId", hostStripeAccountId);
          if (order.paymentMethod.data.customerIdForHost[hostStripeAccountId] === customer) {
            return cb();
          }
        });
        // return cb(new errors.BadRequest(`Customer Id not found`));
      } else {
        return cb(new errors.BadRequest(`Customer Id not found. Order id: ${order.id}`));
      }
    }],

    retrieveCharge: ['validatePaymentMethod', (cb, results) => {
      const chargeId = results.fetchEvent.event.data.object.charge;
      appStripe.charges.retrieve(chargeId, {
        stripe_account: body.user_id
      })
      .then(charge => {
        if (!charge) {
          return cb(new errors.BadRequest(`ChargeId not found: ${chargeId}`));
        }
        debug("retrieveCharge", charge && charge.id);
        return cb(null, charge);
      })
      .catch(cb);
    }],

    retrieveBalance: ['retrieveCharge', (cb, results) => {
      const charge = results.retrieveCharge;
      appStripe.balance.retrieveTransaction(charge.balance_transaction, {
        stripe_account: body.user_id
      })
      .then(balanceTransaction => {
        if (!balanceTransaction) {
          return cb(new errors.BadRequest(`Balance transaction not found for chargeId: ${charge.id}`));
        }
        return cb(null, balanceTransaction);
      })
      .catch(cb);
    }],

    createTransaction: ['retrieveBalance', (cb, results) => {
      const order = results.fetchOrder;
      const { stripeSubscription } = results.fetchEvent;
      const collective = order.collective || {};
      const charge = results.retrieveCharge;
      const balanceTransaction = results.retrieveBalance;
      const fees = extractFees(balanceTransaction);
      const { hostFeePercent } = collective;

      // Now we record a new transaction
      const newTransaction = {
        OrderId: order.id,
        amount: stripeSubscription.amount,
        currency: stripeSubscription.currency,
        hostCurrency: balanceTransaction.currency,
        amountInHostCurrency: balanceTransaction.amount,
        hostCurrencyFxRate: order.totalAmount/balanceTransaction.amount,
        hostFeeInHostCurrency: parseInt(balanceTransaction.amount*hostFeePercent/100, 10),
        platformFeeInHostCurrency: fees.applicationFee,
        paymentProcessorFeeInHostCurrency: fees.stripeFee,
        data: {charge, balanceTransaction},
        description: `${order.Subscription.interval}ly recurring subscription`,
      };

      debug("stripeSubscription", stripeSubscription);
      debug("balanceTransaction", balanceTransaction);
      debug("newTransaction", newTransaction);

      models.Transaction.createFromPayload({
        CreatedByUserId: order.CreatedByUserId,
        FromCollectiveId: order.FromCollectiveId,
        CollectiveId: order.CollectiveId,
        transaction: newTransaction,
        PaymentMethodId: order.PaymentMethodId
      })
      .then(t => cb(null, t))
      .catch(cb);
    }],

    sendInvoice: ['createTransaction', (cb, results) => {
      const order = results.fetchOrder;
      const transaction = results.createTransaction;
      // We only send an invoice for orders > $10 equivalent
      if (order.totalAmount < 10 * currencies[order.currency].fxrate * 100) return cb(null);
      const user = order.createdByUser || {};
      const collective = order.collective || {};
      const subscription = order.Subscription;
      collective.getRelatedCollectives(2, 0)
      .then((relatedCollectives) => emailLib.send(
        'thankyou',
        user.email,
        { order: order.info,
          transaction: transaction.info,
          user: user.info,
          firstPayment: false,
          collective: collective.info,
          relatedCollectives,
          config: { host: config.host },
          interval: subscription && subscription.interval,
          subscriptionsLink: user.generateLoginLink('/subscriptions')
        }, {
          from: `${collective.name} <hello@${collective.slug}.opencollective.com>`
        }))
      .then(() => cb())
      .catch(cb);
    }]

  }, (err) => {
    if (err) return next(err);

    /**
     * We need to return a 200 to tell stripe to not retry the webhook.
     */
    debug(">>> success");
    res.sendStatus(200);
  });

}
